import { Injectable, UnauthorizedException } from '@nestjs/common';import { PassportStrategy } from '@nestjs/passport';import { ExtractJwt, Strategy } from 'passport-jwt';import { ConfigService } from '@nestjs/config';import { PrismaService } from '../../prisma/prisma.service';/** * Estratégia JWT para autenticação com Passport * * @class JwtStrategy * @extends {PassportStrategy(Strategy)} */@Injectable()export class JwtStrategy extends PassportStrategy(Strategy) {  constructor(    private readonly configService: ConfigService,    private readonly prisma: PrismaService,  ) {    const jwtSecret = configService.get<string>('JWT_SECRET');    if (!jwtSecret) {      throw new Error('JWT_SECRET não está configurado no arquivo .env');    }    super({      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),      ignoreExpiration: false,      secretOrKey: jwtSecret,    });  }  /**   * Valida o payload do token JWT e busca permissões do usuário   *   * @param {any} payload - Payload decodificado do JWT   * @returns {Promise<any>} Dados do usuário autenticado com permissões   * @throws {UnauthorizedException} Se token inválido   */  async validate(payload: any): Promise<any> {    try {      if (!payload || !payload.sub) {        throw new UnauthorizedException('Token inválido');      }      // Buscar permissões do usuário      const userPermissions = await this.prisma.userPermission.findMany({        where: { userId: payload.sub },        include: { permission: true },      });      const permissions = userPermissions.map((up) => up.permission.name);      return {        userId: payload.sub,        email: payload.email,        permissions,      };    } catch (_error) {      throw new UnauthorizedException('Token inválido');    }  }}