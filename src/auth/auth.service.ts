import { Injectable, UnauthorizedException } from '@nestjs/common';import { JwtService } from '@nestjs/jwt';import { PrismaService } from '../prisma/prisma.service';import * as bcrypt from 'bcrypt';/** * Serviço de autenticação responsável por login e validação de usuários * * @class AuthService */@Injectable()export class AuthService {  constructor(    private readonly prisma: PrismaService,    private readonly jwtService: JwtService,  ) {}  /**   * Valida as credenciais do usuário   *   * @param {string} email - Email do usuário   * @param {string} password - Senha em texto plano   * @returns {Promise<any>} Usuário sem a senha, com permissões   * @throws {UnauthorizedException} Se credenciais inválidas   */  async validateUser(email: string, password: string): Promise<any> {    try {      const user = await this.prisma.user.findUnique({        where: { email },        include: {          permissions: {            include: {              permission: true,            },          },        },      });      if (!user) {        throw new UnauthorizedException('Credenciais inválidas');      }      const isPasswordValid = await bcrypt.compare(password, user.password);      if (!isPasswordValid) {        throw new UnauthorizedException('Credenciais inválidas');      }      const { password: _, ...result } = user;      return result;    } catch (error) {      if (error instanceof UnauthorizedException) {        throw error;      }      throw new UnauthorizedException('Erro ao validar usuário');    }  }  /**   * Realiza o login e retorna um token JWT   *   * @param {string} email - Email do usuário   * @param {string} password - Senha do usuário   * @returns {Promise<{access_token: string, user: any}>} Token JWT e dados do usuário   * @throws {UnauthorizedException} Se credenciais inválidas   */  async login(    email: string,    password: string,  ): Promise<{ access_token: string; user: any }> {    try {      const user = await this.validateUser(email, password);      const permissions = user.permissions.map((up) => up.permission.name);      const payload = {        sub: user.id,        email: user.email,        permissions,      };      return {        access_token: this.jwtService.sign(payload),        user: {          id: user.id,          name: user.name,          email: user.email,          permissions: user.permissions.map((up) => ({            id: up.permission.id,            name: up.permission.name,            description: up.permission.description,          })),        },      };    } catch (error) {      if (error instanceof UnauthorizedException) {        throw error;      }      throw new UnauthorizedException('Erro ao realizar login');    }  }}